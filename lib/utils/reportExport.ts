// Report Export Utilities for CURA Platform
export interface ExportOptions {
    format: 'pdf' | 'excel' | 'csv' | 'json';
    filename?: string;
    includeCharts?: boolean;
    includeMetadata?: boolean;
    dateRange?: {
        start: string;
        end: string;
    };
}

export interface ExportData {
    title: string;
    subtitle?: string;
    generatedAt: string;
    generatedBy: string;
    data: any;
    metadata?: Record<string, any>;
    charts?: ChartData[];
}

export interface ChartData {
    type: 'line' | 'bar' | 'pie' | 'area';
    title: string;
    data: any[];
    xAxis?: string;
    yAxis?: string;
}

class ReportExportService {
    // Export data to Excel-compatible CSV format
    exportToExcelCSV(data: ExportData, options: ExportOptions = { format: 'excel' }): string {
        const { title, subtitle, generatedAt, generatedBy, data: reportData } = data;

        let csvContent = '';

        // Add BOM for proper UTF-8 encoding in Excel
        csvContent = '\uFEFF';

        // Add header information with Excel-friendly formatting
        csvContent += `"${title}"\n`;
        if (subtitle) {
            csvContent += `"${subtitle}"\n`;
        }
        csvContent += `"Generated At","${new Date(generatedAt).toLocaleString()}"\n`;
        csvContent += `"Generated By","${generatedBy}"\n`;
        csvContent += '\n';

        // Add data based on structure
        if (Array.isArray(reportData)) {
            // Handle array data (like tables)
            if (reportData.length > 0) {
                const headers = Object.keys(reportData[0]);

                // Add headers with proper Excel escaping
                csvContent += headers.map((header) => `"${header}"`).join(',') + '\n';

                reportData.forEach((row) => {
                    const values = headers.map((header) => {
                        const value = row[header];
                        // Properly format values for Excel
                        if (value === null || value === undefined) {
                            return '""';
                        }
                        if (typeof value === 'number') {
                            return value.toString();
                        }
                        // Escape quotes and wrap in quotes for Excel
                        const stringValue = String(value).replace(/"/g, '""');
                        return `"${stringValue}"`;
                    });
                    csvContent += values.join(',') + '\n';
                });
            }
        } else if (typeof reportData === 'object') {
            // Handle structured object data for Excel
            csvContent += this.addStructuredDataToExcelCSV(reportData);
        }

        return csvContent;
    }

    // Add structured data to Excel CSV in a clean format
    private addStructuredDataToExcelCSV(data: any): string {
        let csvContent = '';

        // Handle summary data
        if (data.summary) {
            csvContent += '"SUMMARY"\n';
            csvContent += '"Metric","Value"\n';
            Object.entries(data.summary).forEach(([key, value]) => {
                const cleanKey = this.formatKeyForCSV(key);
                const cleanValue =
                    typeof value === 'string' ? value.replace(/"/g, '""') : String(value);
                csvContent += `"${cleanKey}","${cleanValue}"\n`;
            });
            csvContent += '\n';
        }

        // Handle hourly distribution
        if (data.hourlyDistribution && Array.isArray(data.hourlyDistribution)) {
            csvContent += '"HOURLY DISTRIBUTION"\n';
            csvContent += '"Hour","Orders","Percentage","Time of Day"\n';
            data.hourlyDistribution.forEach((item: any) => {
                csvContent += `"${item.hour}",${item.orders},"${item.percentage}","${item.timeOfDay}"\n`;
            });
            csvContent += '\n';
        }

        // Handle daily distribution
        if (data.dailyDistribution && Array.isArray(data.dailyDistribution)) {
            csvContent += '"DAILY DISTRIBUTION"\n';
            csvContent += '"Day","Orders","Percentage","Is Weekend"\n';
            data.dailyDistribution.forEach((item: any) => {
                csvContent += `"${item.day}",${item.orders},"${item.percentage}","${item.isWeekend}"\n`;
            });
            csvContent += '\n';
        }

        // Handle monthly distribution
        if (data.monthlyDistribution && Array.isArray(data.monthlyDistribution)) {
            csvContent += '"MONTHLY DISTRIBUTION"\n';
            csvContent += '"Month","Orders","Percentage","Quarter"\n';
            data.monthlyDistribution.forEach((item: any) => {
                csvContent += `"${item.month}",${item.orders},"${item.percentage}","Q${item.quarter}"\n`;
            });
            csvContent += '\n';
        }

        return csvContent;
    }

    // Export data to CSV format
    exportToCSV(data: ExportData, options: ExportOptions = { format: 'csv' }): string {
        const { title, generatedAt, generatedBy, data: reportData } = data;

        let csvContent = '';

        // Add header information
        csvContent += `Report Title,${title}\n`;
        csvContent += `Generated At,${new Date(generatedAt).toLocaleString()}\n`;
        csvContent += `Generated By,${generatedBy}\n`;
        csvContent += '\n';

        // Add data based on structure
        if (Array.isArray(reportData)) {
            // Handle array data (like tables)
            if (reportData.length > 0) {
                const headers = Object.keys(reportData[0]);
                csvContent += headers.join(',') + '\n';

                reportData.forEach((row) => {
                    const values = headers.map((header) => {
                        const value = row[header];
                        // Escape commas and quotes in CSV
                        if (
                            typeof value === 'string' &&
                            (value.includes(',') || value.includes('"'))
                        ) {
                            return `"${value.replace(/"/g, '""')}"`;
                        }
                        return value;
                    });
                    csvContent += values.join(',') + '\n';
                });
            }
        } else if (typeof reportData === 'object') {
            // Handle structured object data (like order timing analytics)
            this.addStructuredDataToCSV(reportData, csvContent);
        }

        return csvContent;
    }

    // Add structured data to CSV in a clean format
    private addStructuredDataToCSV(data: any, csvContent: string): string {
        // Handle summary data
        if (data.summary) {
            csvContent += '\nSUMMARY\n';
            csvContent += 'Metric,Value\n';
            Object.entries(data.summary).forEach(([key, value]) => {
                const cleanKey = this.formatKeyForCSV(key);
                csvContent += `${cleanKey},${value}\n`;
            });
        }

        // Handle hourly distribution
        if (data.hourlyDistribution && Array.isArray(data.hourlyDistribution)) {
            csvContent += '\nHOURLY DISTRIBUTION\n';
            csvContent += 'Hour,Orders,Percentage,Time of Day\n';
            data.hourlyDistribution.forEach((item: any) => {
                csvContent += `${item.hour},${item.orders},${item.percentage},${item.timeOfDay}\n`;
            });
        }

        // Handle daily distribution
        if (data.dailyDistribution && Array.isArray(data.dailyDistribution)) {
            csvContent += '\nDAILY DISTRIBUTION\n';
            csvContent += 'Day,Orders,Percentage,Is Weekend\n';
            data.dailyDistribution.forEach((item: any) => {
                csvContent += `${item.day},${item.orders},${item.percentage},${item.isWeekend}\n`;
            });
        }

        // Handle monthly distribution
        if (data.monthlyDistribution && Array.isArray(data.monthlyDistribution)) {
            csvContent += '\nMONTHLY DISTRIBUTION\n';
            csvContent += 'Month,Orders,Percentage,Quarter\n';
            data.monthlyDistribution.forEach((item: any) => {
                csvContent += `${item.month},${item.orders},${item.percentage},Q${item.quarter}\n`;
            });
        }

        return csvContent;
    }

    // Format camelCase keys to readable format
    private formatKeyForCSV(key: string): string {
        return key
            .replace(/([A-Z])/g, ' $1')
            .replace(/^./, (str) => str.toUpperCase())
            .trim();
    }

    // Export data to JSON format
    exportToJSON(data: ExportData, options: ExportOptions = { format: 'json' }): string {
        const exportObject = {
            report: {
                title: data.title,
                subtitle: data.subtitle,
                generatedAt: data.generatedAt,
                generatedBy: data.generatedBy,
                format: 'json',
                version: '1.0',
            },
            data: data.data,
            metadata: options.includeMetadata ? data.metadata : undefined,
            charts: options.includeCharts ? data.charts : undefined,
        };

        return JSON.stringify(exportObject, null, 2);
    }

    // Generate Excel-compatible data structure
    exportToExcel(data: ExportData, options: ExportOptions = { format: 'excel' }): any {
        // This would typically use a library like xlsx or exceljs
        // For now, return a structure that could be used with such libraries

        const workbook = {
            SheetNames: ['Summary', 'Data'],
            Sheets: {
                Summary: {
                    '!ref': 'A1:B10',
                    A1: { v: 'Report Title', t: 's' },
                    B1: { v: data.title, t: 's' },
                    A2: { v: 'Generated At', t: 's' },
                    B2: { v: new Date(data.generatedAt).toLocaleString(), t: 's' },
                    A3: { v: 'Generated By', t: 's' },
                    B3: { v: data.generatedBy, t: 's' },
                    A4: { v: 'Format', t: 's' },
                    B4: { v: 'Excel', t: 's' },
                },
                Data: this.convertDataToExcelSheet(data.data),
            },
        };

        return workbook;
    }

    // Convert data to Excel sheet format
    private convertDataToExcelSheet(data: any): any {
        if (Array.isArray(data)) {
            const sheet: any = {};
            let rowIndex = 1;

            if (data.length > 0) {
                const headers = Object.keys(data[0]);

                // Add headers
                headers.forEach((header, colIndex) => {
                    const cellAddress = this.getCellAddress(rowIndex, colIndex + 1);
                    sheet[cellAddress] = { v: header, t: 's' };
                });

                rowIndex++;

                // Add data rows
                data.forEach((row) => {
                    headers.forEach((header, colIndex) => {
                        const cellAddress = this.getCellAddress(rowIndex, colIndex + 1);
                        const value = row[header];
                        sheet[cellAddress] = {
                            v: value,
                            t: typeof value === 'number' ? 'n' : 's',
                        };
                    });
                    rowIndex++;
                });

                sheet['!ref'] = `A1:${this.getCellAddress(rowIndex - 1, headers.length)}`;
            }

            return sheet;
        }

        // Handle object data
        const sheet: any = {};
        let rowIndex = 1;

        Object.entries(data).forEach(([key, value]) => {
            sheet[this.getCellAddress(rowIndex, 1)] = { v: key, t: 's' };
            sheet[this.getCellAddress(rowIndex, 2)] = {
                v: typeof value === 'object' ? JSON.stringify(value) : value,
                t: 's',
            };
            rowIndex++;
        });

        sheet['!ref'] = `A1:B${rowIndex - 1}`;
        return sheet;
    }

    // Get Excel cell address (e.g., A1, B2, etc.)
    private getCellAddress(row: number, col: number): string {
        let colStr = '';
        while (col > 0) {
            colStr = String.fromCharCode(65 + ((col - 1) % 26)) + colStr;
            col = Math.floor((col - 1) / 26);
        }
        return colStr + row;
    }

    // Generate PDF-compatible data structure
    exportToPDF(data: ExportData, options: ExportOptions = { format: 'pdf' }): any {
        // This would typically use a library like jsPDF or PDFKit
        // Return a structure that could be used with such libraries

        return {
            title: data.title,
            subtitle: data.subtitle,
            header: {
                generatedAt: new Date(data.generatedAt).toLocaleString(),
                generatedBy: data.generatedBy,
            },
            content: this.formatDataForPDF(data.data),
            charts: options.includeCharts ? data.charts : undefined,
            metadata: options.includeMetadata ? data.metadata : undefined,
            footer: {
                pageNumbers: true,
                timestamp: true,
            },
        };
    }

    // Format data for PDF display
    private formatDataForPDF(data: any): any {
        if (Array.isArray(data)) {
            return {
                type: 'table',
                headers: data.length > 0 ? Object.keys(data[0]) : [],
                rows: data.map((row) => Object.values(row)),
            };
        }

        if (typeof data === 'object' && data !== null) {
            return {
                type: 'keyValue',
                pairs: Object.entries(data).map(([key, value]) => ({
                    key,
                    value: typeof value === 'object' ? JSON.stringify(value, null, 2) : value,
                })),
            };
        }

        return {
            type: 'text',
            content: String(data),
        };
    }

    // Download file with given content
    downloadFile(content: string | Blob, filename: string, mimeType: string): void {
        const blob = content instanceof Blob ? content : new Blob([content], { type: mimeType });
        const url = URL.createObjectURL(blob);

        const link = document.createElement('a');
        link.href = url;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);

        URL.revokeObjectURL(url);
    }

    // Main export function
    async exportReport(data: ExportData, options: ExportOptions): Promise<void> {
        const timestamp = new Date().toISOString().split('T')[0];
        const baseFilename = options.filename || `cura_report_${timestamp}`;

        let content: string | Blob;
        let mimeType: string;
        let filename: string;

        switch (options.format) {
            case 'csv':
                content = this.exportToCSV(data, options);
                mimeType = 'text/csv';
                filename = `${baseFilename}.csv`;
                break;

            case 'json':
                content = this.exportToJSON(data, options);
                mimeType = 'application/json';
                filename = `${baseFilename}.json`;
                break;

            case 'excel':
                // Create Excel-compatible CSV format that Excel can open properly
                content = this.exportToExcelCSV(data, options);
                mimeType = 'application/vnd.ms-excel';
                filename = `${baseFilename}.xls`;
                break;

            case 'pdf':
                // In a real implementation, you would use a library like jsPDF
                const pdfData = this.exportToPDF(data, options);
                content = JSON.stringify(pdfData); // Placeholder
                mimeType = 'application/pdf';
                filename = `${baseFilename}.pdf`;
                break;

            default:
                throw new Error(`Unsupported export format: ${options.format}`);
        }

        this.downloadFile(content, filename, mimeType);
    }

    // Generate sample report data for testing
    generateSampleData(): ExportData {
        return {
            title: 'Sample CURA Report',
            subtitle: 'Generated for testing purposes',
            generatedAt: new Date().toISOString(),
            generatedBy: 'admin@cura.com',
            data: [
                {
                    id: 1,
                    name: 'Paracetamol 500mg',
                    category: 'Prescription',
                    sales: 234,
                    revenue: 5850,
                },
                {
                    id: 2,
                    name: 'Vitamin D3 1000IU',
                    category: 'Supplements',
                    sales: 189,
                    revenue: 8505,
                },
                {
                    id: 3,
                    name: 'Baby Formula Powder',
                    category: 'Baby Care',
                    sales: 156,
                    revenue: 18720,
                },
                {
                    id: 4,
                    name: 'Omega-3 Fish Oil',
                    category: 'Supplements',
                    sales: 134,
                    revenue: 12730,
                },
                {
                    id: 5,
                    name: 'Moisturizing Face Cream',
                    category: 'Skincare',
                    sales: 112,
                    revenue: 9520,
                },
            ],
            metadata: {
                reportType: 'Product Performance',
                dateRange: '2024-01-01 to 2024-01-31',
                totalProducts: 5,
                totalSales: 825,
                totalRevenue: 55325,
            },
            charts: [
                {
                    type: 'bar',
                    title: 'Sales by Product',
                    data: [
                        { name: 'Paracetamol 500mg', value: 234 },
                        { name: 'Vitamin D3 1000IU', value: 189 },
                        { name: 'Baby Formula Powder', value: 156 },
                        { name: 'Omega-3 Fish Oil', value: 134 },
                        { name: 'Moisturizing Face Cream', value: 112 },
                    ],
                    xAxis: 'name',
                    yAxis: 'value',
                },
            ],
        };
    }
}

export const reportExportService = new ReportExportService();
